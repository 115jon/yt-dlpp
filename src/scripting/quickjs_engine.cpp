#include "quickjs_engine.hpp"

#include <spdlog/spdlog.h>

namespace ytdlpp::scripting {

JsEngine::JsEngine(boost::asio::any_io_executor ex, BytecodeConfig config)
	: ex_(std::move(ex)), rt_(JS_NewRuntime()), config_(config) {
	if (!rt_) { throw std::runtime_error("Failed to create QuickJS runtime"); }

	// Apply memory limits for safety on all platforms
	if (config_.max_memory > 0) {
		JS_SetMemoryLimit(rt_, config_.max_memory);
		spdlog::debug("QuickJS memory limit set to {} MB",
					  config_.max_memory / BytecodeConfig::kMB);
	}

	if (config_.max_stack_size > 0) {
		JS_SetMaxStackSize(rt_, config_.max_stack_size);
		spdlog::debug("QuickJS stack limit set to {} KB",
					  config_.max_stack_size / BytecodeConfig::kKB);
	}

	ctx_ = JS_NewContext(rt_);
	if (!ctx_) {
		JS_FreeRuntime(rt_);
		throw std::runtime_error("Failed to create QuickJS context");
	}
}

JsEngine::~JsEngine() {
	if (ctx_) JS_FreeContext(ctx_);
	if (rt_) JS_FreeRuntime(rt_);
}

std::string JsEngine::get_exception_str() {
	JSValue exception_val = JS_GetException(ctx_);
	const char *str = JS_ToCString(ctx_, exception_val);
	std::string res = str ? str : "Unknown JS Exception";
	if (str) JS_FreeCString(ctx_, str);
	JS_FreeValue(ctx_, exception_val);
	return res;
}

size_t JsEngine::get_memory_usage() const {
	JSMemoryUsage usage;
	JS_ComputeMemoryUsage(rt_, &usage);
	return static_cast<size_t>(usage.memory_used_size);
}

Result<void> JsEngine::evaluate(const std::string &code) {
	std::lock_guard<std::mutex> lock(mutex_);

	JSValue ret = JS_Eval(
		ctx_, code.c_str(), code.length(), "<input>", JS_EVAL_TYPE_GLOBAL);

	if (JS_IsException(ret)) {
		std::string err = get_exception_str();
		JS_FreeValue(ctx_, ret);
		spdlog::error("JS Evaluation failed: {}", err);
		return outcome::failure(errc::extraction_failed);
	}

	JS_FreeValue(ctx_, ret);
	return outcome::success();
}

Result<void> JsEngine::evaluate_with_cache(
	const std::string &code,
	const std::optional<std::vector<uint8_t>> &cached_bytecode,
	std::optional<std::vector<uint8_t>> *out_bytecode) {
	std::lock_guard<std::mutex> lock(mutex_);

	// If we have cached bytecode, load it directly (fast path)
	if (cached_bytecode && !cached_bytecode->empty()) {
		spdlog::debug("Loading pre-compiled bytecode ({} bytes)",
					  cached_bytecode->size());

		JSValue obj =
			JS_ReadObject(ctx_, cached_bytecode->data(),
						  cached_bytecode->size(), JS_READ_OBJ_BYTECODE);

		if (JS_IsException(obj)) {
			std::string err = get_exception_str();
			spdlog::warn(
				"Failed to load bytecode, falling back to source: {}", err);
			// Fall through to source compilation
		} else {
			// Evaluate the loaded bytecode function
			JSValue ret = JS_EvalFunction(ctx_, obj);
			if (JS_IsException(ret)) {
				std::string err = get_exception_str();
				JS_FreeValue(ctx_, ret);
				spdlog::error("Bytecode execution failed: {}", err);
				return outcome::failure(errc::extraction_failed);
			}
			JS_FreeValue(ctx_, ret);
			spdlog::debug("Bytecode loaded and executed successfully");
			return outcome::success();
		}
	}

	// Compile source code
	if (out_bytecode && config_.enable_bytecode_cache) {
		// Compile with bytecode generation
		spdlog::debug("Compiling source with bytecode generation ({} bytes)",
					  code.size());

		JSValue compiled =
			JS_Eval(ctx_, code.c_str(), code.length(), "<input>",
					JS_EVAL_TYPE_GLOBAL | JS_EVAL_FLAG_COMPILE_ONLY);

		if (JS_IsException(compiled)) {
			std::string err = get_exception_str();
			JS_FreeValue(ctx_, compiled);
			spdlog::error("JS Compilation failed: {}", err);
			return outcome::failure(errc::extraction_failed);
		}

		// Write bytecode
		size_t bytecode_len = 0;
		uint8_t *bytecode_data = JS_WriteObject(
			ctx_, &bytecode_len, compiled, JS_WRITE_OBJ_BYTECODE);

		if (bytecode_data && bytecode_len > 0) {
			out_bytecode->emplace(bytecode_data, bytecode_data + bytecode_len);
			js_free(ctx_, bytecode_data);
			spdlog::debug("Generated bytecode ({} bytes)", bytecode_len);
		}

		// Execute the compiled code
		JSValue ret = JS_EvalFunction(ctx_, compiled);
		if (JS_IsException(ret)) {
			std::string err = get_exception_str();
			JS_FreeValue(ctx_, ret);
			spdlog::error("Compiled execution failed: {}", err);
			return outcome::failure(errc::extraction_failed);
		}
		JS_FreeValue(ctx_, ret);
	} else {
		// Simple evaluation without bytecode generation
		JSValue ret = JS_Eval(
			ctx_, code.c_str(), code.length(), "<input>", JS_EVAL_TYPE_GLOBAL);

		if (JS_IsException(ret)) {
			std::string err = get_exception_str();
			JS_FreeValue(ctx_, ret);
			spdlog::error("JS Evaluation failed: {}", err);
			return outcome::failure(errc::extraction_failed);
		}
		JS_FreeValue(ctx_, ret);
	}

	return outcome::success();
}

Result<std::vector<uint8_t>> JsEngine::compile_to_bytecode(
	const std::string &code) {
	std::lock_guard<std::mutex> lock(mutex_);

	JSValue compiled = JS_Eval(ctx_, code.c_str(), code.length(), "<input>",
							   JS_EVAL_TYPE_GLOBAL | JS_EVAL_FLAG_COMPILE_ONLY);

	if (JS_IsException(compiled)) {
		std::string err = get_exception_str();
		JS_FreeValue(ctx_, compiled);
		spdlog::error("JS Compilation failed: {}", err);
		return outcome::failure(errc::extraction_failed);
	}

	size_t bytecode_len = 0;
	uint8_t *bytecode_data =
		JS_WriteObject(ctx_, &bytecode_len, compiled, JS_WRITE_OBJ_BYTECODE);

	JS_FreeValue(ctx_, compiled);

	if (!bytecode_data || bytecode_len == 0) {
		spdlog::error("Failed to generate bytecode");
		return outcome::failure(errc::extraction_failed);
	}

	std::vector<uint8_t> result(bytecode_data, bytecode_data + bytecode_len);
	js_free(ctx_, bytecode_data);

	return result;
}

Result<void> JsEngine::load_bytecode(const std::vector<uint8_t> &bytecode) {
	std::lock_guard<std::mutex> lock(mutex_);

	JSValue obj = JS_ReadObject(
		ctx_, bytecode.data(), bytecode.size(), JS_READ_OBJ_BYTECODE);

	if (JS_IsException(obj)) {
		std::string err = get_exception_str();
		spdlog::error("Failed to read bytecode: {}", err);
		return outcome::failure(errc::extraction_failed);
	}

	JSValue ret = JS_EvalFunction(ctx_, obj);
	if (JS_IsException(ret)) {
		std::string err = get_exception_str();
		JS_FreeValue(ctx_, ret);
		spdlog::error("Bytecode execution failed: {}", err);
		return outcome::failure(errc::extraction_failed);
	}

	JS_FreeValue(ctx_, ret);
	return outcome::success();
}

Result<std::string> JsEngine::call_function(
	const std::string &func_name, const std::vector<std::string> &args) {
	std::lock_guard<std::mutex> lock(mutex_);

	JSValue global_obj = JS_GetGlobalObject(ctx_);
	JSValue func_obj = JS_GetPropertyStr(ctx_, global_obj, func_name.c_str());
	JS_FreeValue(ctx_, global_obj);

	if (!JS_IsFunction(ctx_, func_obj)) {
		JS_FreeValue(ctx_, func_obj);
		spdlog::error("Function not found or not a function: {}", func_name);
		return outcome::failure(errc::extraction_failed);
	}

	std::vector<JSValue> js_args;
	js_args.reserve(args.size());
	for (const auto &arg : args) {
		js_args.push_back(JS_NewString(ctx_, arg.c_str()));
	}

	JSValue ret = JS_Call(ctx_, func_obj, JS_UNDEFINED,
						  static_cast<int>(js_args.size()), js_args.data());

	for (auto val : js_args) { JS_FreeValue(ctx_, val); }
	JS_FreeValue(ctx_, func_obj);

	if (JS_IsException(ret)) {
		std::string err = get_exception_str();
		JS_FreeValue(ctx_, ret);
		spdlog::error("JS Call failed: {}", err);
		return outcome::failure(errc::extraction_failed);
	}

	const char *res_str = JS_ToCString(ctx_, ret);
	std::string result = res_str ? res_str : "";
	if (res_str) JS_FreeCString(ctx_, res_str);
	JS_FreeValue(ctx_, ret);

	return result;
}

}  // namespace ytdlpp::scripting
